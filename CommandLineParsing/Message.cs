using CommandLineParsing.Output;
using System;

namespace CommandLineParsing
{
    /// <summary>
    /// Represents an error-message generated by a command or parameter.
    /// Strings are implicitly converted to <see cref="Message"/>.
    /// </summary>
    public class Message
    {
        /// <summary>
        /// A unique <see cref="Message"/>, representing that no error has occured.
        /// When performing validations and no error error occurs this value should be returned.
        /// </summary>
        public static Message NoError { get; } = new Message();

        private readonly ConsoleString _content;

        private Message()
        {
            IsError = false;
            _content = default;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Message"/> class, that is considered an error.
        /// </summary>
        /// <param name="content">The message that represents the error feedback.</param>
        public Message(ConsoleString content)
        {
            IsError = true;
            _content = content ?? throw new ArgumentNullException(nameof(content));

            if (_content.Length == 0)
                throw new ArgumentException($"{nameof(Message)} cannot use an empty {nameof(ConsoleString)}.");
        }

        /// <summary>
        /// Combines two instances of <see cref="Message"/> into a new <see cref="Message"/>, joining them with a newline character.
        /// This represents the idea of printing one <see cref="Message"/> and then another.
        /// </summary>
        /// <param name="first">The first message.</param>
        /// <param name="second">The second message.</param>
        /// <returns>
        /// A new <see cref="Message"/> containing <paramref name="first"/> and <paramref name="second"/>.
        /// </returns>
        public static Message operator +(Message first, Message second)
        {
            if (first == null)
                throw new ArgumentNullException(nameof(first));
            if (second == null)
                throw new ArgumentNullException(nameof(second));

            if (!first.IsError)
                return second;
            if (!second.IsError)
                return first;

            return new Message(first.Content + second.Content);
        }

        /// <summary>
        /// Gets the error associated with this <see cref="Message"/>.
        /// Will contain <see cref="ConsoleString.Empty"/> if <see cref="IsError"/> is false.
        /// </summary>
        public ConsoleString Content => IsError ? _content : throw new InvalidOperationException($"Only error messages have {nameof(Content)}. Check {nameof(IsError)} before accessing.");
        /// <summary>
        /// Gets a value indicating whether this <see cref="Message"/> is an error message.
        /// Only the <see cref="NoError"/> message is not considered an error.
        /// </summary>
        /// <value>
        ///   <c>true</c> if this instance is error; otherwise, <c>false</c>.
        /// </value>
        public bool IsError { get; }
    }

    public class Message<T>
    {
        public static Message<T> NoError { get; } = new Message<T>(default(T));

        private readonly ConsoleString _content;
        private readonly T _value;

        public Message(T value)
        {
            IsError = false;
            _content = default;
            _value = value;
        }
        public Message(ConsoleString content)
        {
            IsError = true;
            _content = content ?? throw new ArgumentNullException(nameof(content));
            _value = default;

            if (content.Length == 0)
                throw new ArgumentException($"{nameof(Message)} cannot use an empty {nameof(ConsoleString)}.");
        }

        public ConsoleString Content => IsError ? _content : throw new InvalidOperationException($"Only error messages have {nameof(Content)}. Check {nameof(IsError)} before accessing.");
        public T Value => IsError ? throw new InvalidOperationException($"Only succes messages have {nameof(Value)}. Check {nameof(IsError)} before accessing.") : _value;

        public bool IsError { get; }
    }
}
